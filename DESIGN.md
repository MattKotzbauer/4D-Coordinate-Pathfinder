The entire pathfinder is contained in the file ‘4DPathfinder.cpp’. I was ready to incorporate other files if needed to simplify the functions, but was able to keep the code to 200 or so lines and found that keeping it to 1 file helped overall readability (as the 4 functions are very interlinked). 

The program, due to being in C++, starts by running ‘main()’. Main serves as our driver function, initializing the variables, calling the input function (inputPoint(), which takes a point while accounting for incorrect values), and then calling the pathfinding function, ‘gridSearch()’. GridSearch is where Breadth-First Search (BFS) is used to traverse adjacent elements of the 4D grid, initiating from the start point. The BFS firstly checks all points of path length 1 from the start, then all points of path length 2 from the start, continuing until it finds the endpoint. The most efficient path to each point in the grid is kept as the BFS progresses. Hence, the first path that finds our ending point is guaranteed to be the shortest possible one. Once we find this shortest path, we terminate the function (to avoid searching unnecessary parts of the grid), now able to refer to the pathfinder’s results in main (stored in the variable allPaths[targetPoint[0]][targetPoint[1]][targetPoint[2]][targetPoint[3]]). 

The function ‘pathUtilityFunction’ is included due to repetitive code that I found when first writing the BFS. I found that, in all 8 directions that the search launches for each point, code was largely repeated (with the modification of the point being the only area where it differentiates). By writing this helper function and instead calling it to run the breadth-first search and update the vector of paths, I was able to reduce the amount of code from over 400 lines to around 200. 

In creating the code, I prioritized readability and organization to the fullest possible extent (both for outside readability, and so that I didn’t get lost in my own code). The gridSearch function is relatively dense due to calling the helper function's many parameters: just think of calls to the helper function as the updates for the BFS and paths. There wasn’t much way around multidimensional vectors and longer notations due to working in the 4th dimension, but I arrived at methods of notation that I thought to be relatively clear. The code and notation can be pretty difficult to wrap your mind around (made even more difficult by the fact that the 4th dimension is something we can’t directly visualize), but hopefully the code makes for a fun read.


